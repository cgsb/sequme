#!/usr/bin/python

#
# Small script that takes the output from MACS of chromosomal
# locations and determines the corresponding gene(s) at that
# region.  
# Performs lookups per chromosomal location using RefGene database, 
# annotating with gene name if one is found, as well as strand
# information and specifying if region is coding or non-coding.
#

#
# $Id: curate_peaks.py,v 1.3 2010-10-24 14:39:39 kirigf01 Exp $
# $Header: /home/kirigf01/cvs/src/pipeline/tools/curate_peaks.py,v 1.3 2010-10-24 14:39:39 kirigf01 Exp $
#

__author__ = "Francis Kirigin, francis.kirigin@med.nyu.edu"
__version__ = "$Id: curate_peaks.py,v 1.3 2010-10-24 14:39:39 kirigf01 Exp $"
__date__ = "$Date: 2010-10-24 14:39:39 $"
__copyright__ = "Copyright (c) 2010 Francis Kirigin, Laboratory of Dan R. Littman, NYU School of Medicine"
__license__ = "Python"


"""

@notes:

Contains various API to perform queries on a specified genomic region
(assumed to be a called peak from ChIP-seq analysis, though just queries
as chromosomal point or range).

Performs lookup on RefGeneDB, which (amongst other things) provides
the common gene name (field: 'name2'), in the event common name is
desired (biologists like common names).

To find all genes in a genomic region, look up on both the low
and high chromosomal positions, report if intergenic, intronic,
or exonic.

Include gene name, coding or noncoding, and strand at very end.


***
*** TO DO
***

  1) Determine if anti-sense strand should determine summit: subtract
     summit offset from the end coordinate, instead of adding summit
     offset to start coordinate on reverse strand


***
*** NOTES ON INPUT DATA
***

Sample MACS output:

::::::::::::::
IRF4-Th0-1044-1043-20100609-1647_peaks.xls
::::::::::::::
# This file is generated by MACS
# ARGUMENTS LIST:
# name = IRF4-Th0-1044-1043-20100609-1647
# format = SAM
# ChIP-seq file = chip-1044-k1-best.sam
# control file = ctrl-1043-k1-best.sam
# effective genome size = 2.70e+09
# tag size = 25
# band width = 300
# model fold = 15
# pvalue cutoff = 1.00e-10
# Ranges for calculating regional lambda are : peak_region,1000,5000,10000
# unique tags in treatment: 18739865
# total tags in treatment: 21230615
# unique tags in control: 19248099
# total tags in control: 21555615
# d = 132
chr	start	end	length	summit	tags	-10*log10(pvalue)	fold_enrichment	FDR(%)
chr1	4590720	4591282	563	315	55	416.30	46.49	0.22
chr1	4847397	4848101	705	385	46	188.28	10.97	0.26
chr1	6396464	6396988	525	209	28	115.51	13.44	0.37
..
chr1	10582710	10583137	428	243	22	124.44	17.88	0.30
chr1	13145237	13146030	794	386	187	1384.68	60.52	1.90


*** INPUT EXAMPLE: CALLED PEAKS ***

LOCATION: littman60:~/kirigf01/lab/maria/hudsonvalley/Th17/input/ChIP-Seq/MACS

INFO: Peak information includes:

- Chromosome name
- Start position of peak
- End position of peak

- Length of peak region
- Peak summit position related to the start position of peak region
- Number of tags in peak region

- P-value as (-10*log10(pvalue)): for peak region (e.g. if pvalue = 1e-10, -10*log10(pvalue) = 100)
- Fold enrichment: for given region against a random Poisson distribution taken over a local lambda
- FDR: percentage

************************************

"""

# Generate report file, date-stamped

import site
from datetime import datetime, date, time
from time import gmtime, strftime

dtag = datetime.now().strftime("%Y%m%d-%H%M")
chip_rpt = "UNKNOWN"

def get_header() :
    pre_hdr = "# GENERATED BY:\t" +__version__ + "\n# INPUT:\t" + chip_rpt + "\n# TIMESTAMP:\t" + dtag
    pre_hdr +="\n# AUTHOR:  \t" + __author__ + "\n# NOTICE:  \t" + __copyright__ + "\n"
    print "HEADER: ", pre_hdr

    return pre_hdr
        

# 
# MACS output has peak information listed as:
# chr	start	end	length	summit	tags	-10*log10(pvalue)	fold_enrichment	FDR(%)
#

def load_peaks(peaks_rpt) : 
    do_debug = False

    handle = open(peaks_rpt, "r")
    lines = handle.readlines()
    handle.close()
    print "load_peaks: FILE: %s" % peaks_rpt

    called_peaks = []
    in_header = True
    nth = 0

    for entry in lines :
        line = entry.rstrip()

        if line.find("#") > -1 or line.find("summit") > -1 :
            print "SKIPPING: ", line
            continue        
        
        pinfo = line.split("\t")

        peak = {}
        peak["chrom"] = pinfo[0]
        peak["start"] = int(pinfo[1])
        peak["end"] = int(pinfo[2])
        peak["length"] = int(pinfo[3])
        peak["summit"] = int(pinfo[4])
        peak["tags"] = int(pinfo[5])
        peak["nlogpvalue"] = float(pinfo[6])
        peak["fold_enrich"] = float(pinfo[7])
        peak["fdr"] = float(pinfo[8])
        peak["info"] = pinfo
        peak["data_entry"] = entry

        called_peaks.append(peak)
        nth += 1
        
        if do_debug :
            print "PEAK %d: INFO: " % nth, pinfo, "\nVAL: ", peak

    print "load_peaks: rpt=%s total=%d" % (peaks_rpt, len(called_peaks))

    return called_peaks


# Expects output in form:
#  chr1	13145401	13145910	OTHER_INTRON	Ncoa2	410.95		
#  chr1	13742571	13743170	INTERGENIC	NA	670.17		
#  chr1	20715614	20716507	INTERGENIC	NA	1482.78		
#  chr1	20720564	20721508	FIRST_EXON	Il17a	752.61		
#  chr1	20721559	20721951	FIRST_INTRON	Il17a	448.30		
#  chr1	20726619	20727049	INTERGENIC	NA	172.08		

def load_myers_peaks(peaks_rpt) : 
    do_debug = False

    handle = open(peaks_rpt, "r")
    lines = handle.readlines()
    handle.close()
    n_peaks = len(lines)
    
    print "load_myers_peaks: FILE: %s" % peaks_rpt

    called_peaks = []
    in_header = True
    nth = 0
    gene_peaks = {}
    n_mapped = 0

    for entry in lines :
        line = entry.rstrip()

        if line.find("#") > -1 or line.find("summit") > -1 :
            print "SKIPPING: ", line
            continue        
        print "LINE: ", line
        
        pinfo = line.split("\t")
        gene = pinfo[4]

        if gene == "NA" :
            print "SKIPPING intergenic: ", line
            continue

        region = pinfo[3]
        fold_enrich = pinfo[5]

        if not gene_peaks.has_key(gene) :
            gene_peaks[gene] = {}
            gene_peaks[gene]["peaks"] = []
            gene_peaks[gene]["total"] = 0
            gene_peaks[gene]["region"] = []
            gene_peaks[gene]["fold_enrichment"] = []
                
        gene_peaks[gene]["peaks"].append(pinfo)
        gene_peaks[gene]["total"] += 1
        gene_peaks[gene]["fold_enrichment"].append(fold_enrich)
        gene_peaks[gene]["region"].append(region)
        print "MAPPED PEAK REGION TO GENE: %s" % gene, gene_peaks[gene]

        n_mapped += 1

    print "MAPPED %d PEAKS OVER %d TOTAL GENES" % (n_mapped, len(gene_peaks))

    return n_peaks, gene_peaks


def annotate_peaks(peaks) :    

    """
    Performs lookup on RefGeneDB, which (amongst other things) provides
    the common gene name (field: 'name2'), in the event common name is
    desired (biologists like common names).

    To find all genes in a genomic region, look up on both the low
    and high chromosomal positions, report if intergenic, intronic,
    or exonic.

    Include gene name, coding or noncoding, and strand at very end, as
    well as other introspective transcript information and curation
    (see below).
    """
    
    import RefGeneDB

    rgene_db = RefGeneDB.RefGeneDB()
    rgene_db.connect()

    summit_genes = []
    gene2peaks = {}
    n_found = 0
    peak_id = 1
    nth_peak = 0
    peak_rpt = []
    quick_run = False

    pre_hdr = get_header() # "# " +  __version__ + " \n" + __author__ + "\n" + __copyright__ + "\n"
    header = pre_hdr + "# id\tn_genes\tgenes\tchrom\tsummit\tpval\tfold_enrich\tFDR\n"
    peak_rpt.append(header)

    unmatched = []
    hdr = pre_hdr + "# chr\tstart\tend\tlength\tsummit\ttags\t10*log10(pvalue)\tfold_enrichment\tFDR(%)\n"
    unmatched.append(hdr)
    
    for peak in peaks :
        nth_peak += 1
        peak2genes = {}
        nth_chunk = 0
        interval = 10000  #        interval = 2000
                        
        chrom = peak["chrom"]
        summit_offset = int(peak["summit"])
        summit = peak["start"] + summit_offset    
        pos = int(summit)
        pval = peak["nlogpvalue"]
        enrich = peak["fold_enrich"]
        fdr = peak["fdr"]                        
        upstream = summit - interval
        downstream = summit + interval
        print "Calling find_in_range: upstrm=%d downstrm=%d summit=%d" % (upstream, downstream, summit)

        found, ginfo = rgene_db.find_in_range(chrom, upstream, downstream, summit)

        if not found :
            print "Peak not landing in gene region: ", peak["data_entry"], " summit=%d" % summit
            unmatched.append(peak["data_entry"])
            continue

        gene_fld = ""
        gene_lst = "\t"
        genes = ginfo.keys()
        n_genes = len(genes)

        for gene in genes :
            print "Peak: %s:%d adding gene: " % (chrom, pos), gene
            gene_fld += gene + "," + ginfo[gene][0] + ";"
            gene_lst += gene + ","

            d_TSS = ginfo[gene][4]
            d_TES = ginfo[gene][5]
            gclass = ginfo[gene][6]
                                                
            if not gene2peaks.has_key(gene) :
                gene2peaks[gene] = {}
                gene2peaks[gene]["peaks"] = []
                gene2peaks[gene]["class"] = gclass
                gene2peaks[gene]["len"] = ginfo[gene][7]
                gene2peaks[gene]["chrom"] = chrom
                gene2peaks[gene]["strand"] = ginfo[gene][0]

            pinfo = (nth_peak, summit, d_TSS, d_TES, gclass, pval, enrich, fdr)
            gene2peaks[gene]["peaks"].append(pinfo)

            pentry = gene_fld + "\t" + peak["data_entry"] 
            summit_genes.append(pentry)
            n_found += 1                
                
        pentry = str(nth_peak) + "\t" + str(n_genes) + gene_lst + "\t" + chrom + "\t" + \
                 str(summit) + "\t" + str(pval) + "\t" + str(enrich) + "\t" + str(fdr) + "\n"
        peak_rpt.append(pentry)

        if quick_run and len(summit_genes) > 100 :
            break
        
    rgene_db.close()
    print "Found %d peaks with genes" % len(summit_genes)
    print "\nPRINTING REPORT PER GENE"

    genes = gene2peaks.keys()

    stats_list = []

    header = pre_hdr + "# Gene\tn_peaks\tlen\tstrand\t(peak_id,summit,d_TSS,d_TES,class,pval,fold_enrich,FDR),(..)\n"
    stats_list.append(header)

    for gene in genes :
        stats = ""

        for info in gene2peaks[gene]["peaks"] :
            print "INFO: ", info
            stats += "(" + str(info[0]) + "," + str(info[1]) + "," + str(info[2]) + "," + str(info[3]) + \
                     "," + str(info[4]) + "," + str(info[5]) + "," + str(info[6]) + "," + str(info[7]) + ");"

        n_peaks = len(gene2peaks[gene]["peaks"])
        gene_len = str(gene2peaks[gene]["len"])
        strand = gene2peaks[gene]["strand"]
        print "Gene: %s len=%s npeaks=%d stats: %s" % (gene, gene_len, n_peaks, stats)

        entry = gene + "\t" + str(n_peaks) + "\t" + gene_len + "\t" + strand + "\t" + stats + "\n"
        stats_list.append(entry)

    return gene2peaks, summit_genes, stats_list, peak_rpt, unmatched

    
#
# Generated report of called peaks expected as command argument
#

import os
import sys

if len(sys.argv) < 2 :
    print "usage: python %s MACS-generated report of called peaks" % sys.argv[0]
    sys.exit(1)

chip_rpt = sys.argv[1]
chip_basename = os.path.basename(chip_rpt)
chip_base_idx = chip_basename.find("-2010")
chip_base = chip_basename[0:chip_base_idx]


#print "Examining called peaks: %s (base=%s), RNA-seq: %s" % (chip_rpt, chip_base, rna_rpt)

gene_peaks = []
stats = []

is_myers_data = False
n_peaks = 0
peaks_rpt = []
unmatched = []

if is_myers_data :
    rna_rpt = sys.argv[2]
    rna_basename = os.path.basename(rna_rpt)
    rna_base_idx = rna_basename.find("txt") - 1
    rna_base = rna_basename[0:rna_base_idx]
    n_peaks, gene_peaks = load_myers_peaks(chip_rpt)

else :
    peaks = load_peaks(chip_rpt)
    n_peaks = len(peaks)
    gene_peaks, peak_genes, stats, peaks_rpt, unmatched = annotate_peaks(peaks)

#print "Mapped: %d of %d peaks" % (len(gene_peaks["peaks"]), n_peaks)


# Generate report file, date-stamped

import site
from datetime import datetime, date, time
from time import gmtime, strftime

dtag = datetime.now().strftime("%Y%m%d-%H%M")

curated_fl = chip_base + "-" + dtag + ".txt"
handle = open(curated_fl, "w")
handle.writelines(peak_genes)
handle.close()

stats_fl = chip_base + "-anno-" + dtag + ".txt"
handle = open(stats_fl, "w")
handle.writelines(stats)
handle.close()

peaks_fl = chip_base + "-anno_peaks-" + dtag + ".txt"
handle = open(peaks_fl, "w")
handle.writelines(peaks_rpt)
handle.close()

nm_fl = chip_base + "-nogene_peaks-" + dtag + ".txt"
handle = open(nm_fl, "w")
handle.writelines(unmatched)
handle.close()

all_genes = gene_peaks.keys()

for gene in all_genes :
    print "GENE: ", gene, "PEAKS: ", gene_peaks[gene] 

sys.exit(0)


