#! /bin/sh

# This build system is kind-of an experiment, don't do this at home
# unless you know what you're doing.


if [ -f `basename $0` ]; then
  mkdir -p _build/lib
  if [ $0 -nt _build/please.ml ] || ! [ -f _build/please.ml ] ; then
    SKIP=`awk '/^__OCAML_FOLLOWS__/ { print NR + 1; exit 0; }' $0`
    echo "#$SKIP \"please\"" > _build/please.ml
    tail -n +$SKIP $0 >> _build/please.ml
    #ocamlfind ocamlopt _build/please.ml -package core_extended -linkpkg -thread -o _build/please.opt
    ocamlfind ocamlc _build/please.ml -package core -linkpkg -thread -o _build/please.byte
    if [ $? -ne 0 ]; then
      echo "Compilation of $0 failed"
      exit 2
    fi
  fi
  _build/please.byte $*
else
  echo "$0 should run from the project directory"
  exit 2
fi
exit 0
__OCAML_FOLLOWS__



open Core.Std

let version = "0.2-dev"

let sequme_modules = [
  "Sequme";
  "Sequme_internal_pervasives";
  "Sequme_bowtie";
  "Sequme_cuffdiff";
  "Sequme_cufflinks";
  "Sequme_illumina";
  "Sequme_macs";
  "Sequme_pbs";
  "Sequme_read_type";
  "Sequme_tophat";
  "Sequme_syscall";
  "Sequme_postgres";
  "Sequme_pgpass";
  "Sequme_doc_syntax";
  "Sequme_flow_monad";
  "Sequme_flow";
  "Sequme_flow_list";
  "Sequme_flow_sys";
  "Sequme_flow_io";
  "Sequme_flow_certificate_authority";
  "Sequme_flow_net";
  "Sequme_flow_app_util";
  "Sequme_psql";
]
let sequme_dependencies = [
  "threads";
  "core";
  "core_extended";
  "pgocaml";
  "biocaml";
  "lwt.ssl";
  "lwt.preemptive";
]

let sequme_build_packages = sequme_dependencies @ [
  "sexplib.syntax";
]

let additional_taglines = [
  (* "-tag-line \".git\": -traverse"; *)
  (* "-tag-line \".git\": not_hygienic"; *)
]


open Result

let verbose = ref true

let say fmt = ksprintf (fun s -> if !verbose then printf "%s\n%!" s) fmt
let cmdf fmt =
  ksprintf (fun cmd ->
    say "Running: %s" cmd;
    Unix.system cmd
  ) fmt

let ocamlbuild_sequme () =
  let target = "src/lib/sequme.mllib" in
  Out_channel.with_file target ~f:(fun o ->
    List.iter sequme_modules (fprintf o "%s\n"));
  let ocamlbuild target =
    (* sprintf "ocamlbuild -use-ocamlfind -ocamlc \"ocamlbuild ocamlc -thread\" -pkgs %s -tag \"syntax(camlp4o)\" %s -tag thread -I src/lib sequme.cma" *)
    cmdf "ocamlbuild -tags %s -tag \"syntax_camlp4o\" %s -tag thread -I src/lib sequme.cma"
      (String.concat ~sep:"," (List.map sequme_build_packages (sprintf "pkg_%s")))
      (String.concat ~sep:" " additional_taglines)
      (* target *)
  in
  match ocamlbuild target with
  | Ok () -> say "%s: Done." target; return ()
  | Error e ->
    say "OCamlbuild %s: Failed:\n%s." target
      (Unix.Exit_or_signal.sexp_of_error e |> Sexp.to_string_hum);
    fail ()



let () =
  let open Command in
  let verbose_flag () =
    Spec.(step (fun k v -> verbose := v; k)
      +> flag "verbose" ~aliases:["-V"]
          ~doc:" Display more stuff"
          (no_arg)) in
  run ~version:"0"
    (group ~summary:"Ask me anything but nicely" [
       ("configure",
        basic ~summary:"Configure"
          Spec.(
            verbose_flag ()
          )
          begin fun () ->
            say "TODO"
          end);
       ("build",
        basic ~summary:"Build"
          Spec.(
            verbose_flag ()
          )
          begin fun () ->
            say "build";
            match ocamlbuild_sequme () with
            | Ok () -> exit 0
            | Error () -> exit 1
          end);
       ("clean",
        basic ~summary:"Clean-up the mess"
          Spec.(
            verbose_flag ()
          )
          begin fun () ->
            say "cleaning";
            match cmdf "rm -fr _build/" with
            | Ok () -> exit 0
            | Error _ -> exit 1
          end);
     ])


